<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Log4j的debug日志引起的线上故障]]></title>
    <url>%2F2017%2F12%2F22%2FLog4j%E7%9A%84debug%E6%97%A5%E5%BF%97%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%2F</url>
    <content type="text"><![CDATA[前天下午，运维突然在微信群里说系统流量下跌了，报警邮件也马上来了，都是api接口的time out，查看各种监控工具，zabbix，oneapm，es集群，除了发现流量有下跌，没有别的异常情况。 错误现象 入口流量没有明显增加查看了流量监控，入口流量并没有出现爆发式的增长，很平稳，毕竟我们的流量高峰是在上午，下午3点很难出现高峰 内存、CPU没有明显波动查看系统的运行状态，内存、CPU都没有出现大的波动，说明并没有出现大的计算任务，如果有计算型的任务，会消耗大量的内存和CPU资源 线程数上升迅猛看监控，配置的Tomcat的线程池满了，直接导致了系统的请求超时。[图片] 异常原因分析 既然已经确认是由于线程池的堆积，造成系统的调用超时，那么为什么会突然之间线程池暴涨呢？原因竟然是由于一个同事开启了线上的debug日志跟踪一个问题，持续时间大概20分钟，那么问题来了，log4j开启debug日志，为什么会导致线程池暴涨，造成系统崩溃呢？ 由于log4j同步打日志，当debug日志过多时，频繁的写磁盘文件，api请求的耗时就会增加，那么该api占用的线程的时间就会变长，当占用时间过长，导致线程池不够时，就会出现等待的情况，持续时间一长，等待的线程越来越多，那么就会出现time out了 如何解决 规范日志的打印日志打印不是越多越好，其实只要关键位置的日志往往就可以，比如方法的入口和出口，逻辑的分叉，try/catch的异常日志 异常信息的拼装往往debug的时候，打印日志都是很详细的，比如某个对象的完整信息，Http的完整响应等，这些信息都是比较大的，这时候如果用log.debug(Json.toJSONString(user));也许你觉得这么写也没有什么问题啊，其实不然，虽然如果你设置info级别，这个debug日志是不会打印，但是它会执行Json的转换，这其实也是损耗性能的，系统的性能往往就是细节地方不注意，累计多了，就会出现瓶颈。这时，可以使用级别判断来解决这个问题 if(log.isDebugEnable) { LOG.debug(“params = {}”, JSON.toJSONString(user)); } 可以采用logback、log4j2来替换log4j。log4j2已经发行了稳定版本，logback是基于slf4j的门面实现，性能都比log4j高不少]]></content>
      <categories>
        <category>故障分析</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装Docker]]></title>
    <url>%2F2017%2F12%2F05%2FCentos7%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"><![CDATA[在工作中,总是避免不了搭建各种开发环境，配置各种组件的环境变量，如果你厌倦了以往的方式，你可以尝试使用Docker，本文就从Docker的安装开始。 安装说明 Docker支持以下的CentOS版本：CentOS 7 (64-bit)CentOS 6.5 (64-bit) 或更高的版本前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 yum安装docker 1.使用root权限登陆系统。 2.更新系统包到最新。 yum -y update 3、安装docker yum -y install docker 4、启动docker服务 systemctl start docker.service 5、创建开机启动Docker服务 systemctl enable docker.service 6、查看Docker版本号 docker version 7、运行hello-world docker run hello-world 后续后续的组件，我会尽量用Docker的方式来处理，这样既方便快捷，也完美的解决了一台机器中安装某个服务的多个版本，比如es，redis，后面也会在使用中总结更多的用法。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat的线程安全问题]]></title>
    <url>%2F2017%2F11%2F26%2FSimpleDateFormat%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat在进行日期格式转换时用的很多，但是 DateFormat 和 SimpleDateFormat 类不都是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题 多线程测试12345678910111213141516 * &lt;p&gt; * Date formats are not synchronized. * It is recommended to create separate format instances for each thread. * If multiple threads access a format concurrently, it must be synchronized * externally. * * @see &lt;a href="http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html"&gt;Java Tutorial&lt;/a&gt; * @see java.util.Calendar * @see java.util.TimeZone * @see DateFormat * @see DateFormatSymbols * @author Mark Davis, Chen-Lieh Huang, Alan Liu */public class SimpleDateFormat extends DateFormat &#123;...................｝ 在注视中，明确说明If multiple threads access a format concurrently, it must be synchronized测试代码：12345678910111213141516171819202122public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; 上面的测试方法在多线程下会出现如下异常：123456789101112131415161718192021222324252627282930313233343536Exception in thread "Thread-1" Exception in thread "Thread-3" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)Exception in thread "Thread-8" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2088)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745) 根本原因SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。 在format方法里，有这样一段代码：12private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // Convert input date to time field list calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法： 线程1调用format方法，改变了calendar这个字段。 中断来了。 线程2开始执行，它也改变了calendar。 又中断了。 线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。 分析一下format的实现，我们不难发现，用到成员变量calendar，唯一的好处，就是在调用subFormat时，少了一个参数，却带来了这许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。 这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。 解决办法 每次需要的时候都创建一个新的实例 使用同步：同步SimpleDateFormat对象 使用common-lang中的api中的FastDateFormat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.CountDownLatch;import org.apache.commons.lang3.time.FastDateFormat;import org.junit.Test;/** * 测试时间处理类的线程安全问题 * @Description * @author gaowenming */public class SimpleDateFormatTest &#123; public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; @Test public void testCommonLang() &#123; //CommonLang第三方jar包实现 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; FastDateFormat fdf = FastDateFormat.getInstance(PATTEN); System.out.println(fdf.format(new Date())); Date date = fdf.parse("2013-05-24 06:02:20"); System.out.println(date); countDownLatch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; try &#123; //等待100个线程都执行完 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
</search>
