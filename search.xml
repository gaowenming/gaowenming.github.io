<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用MDC追踪系统日志]]></title>
    <url>%2F2017%2F12%2F30%2F%E4%BD%BF%E7%94%A8MDC%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[在系统开发中，日志必不可少，前段时间我们还因为在线上开启Debug而造成系统故障，所以日志的处理应该让我们更加重视。在线上系统，日志很多，接口之间的日志错乱交替的打印，大大的影响了我们对日志的跟踪，我们要想跟踪一次请求的完整日志，好像都只能通过时间、线程名等信息，但是也无法精确的找出。MDC的出现，完美的解决了这个棘手的问题。 什么是MDC MDC ( Mapped Diagnostic Contexts )，是SLF4J中提供的一个类，专门用来跟踪请求链路的日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.slf4j;import java.io.Closeable;import java.util.Map;import org.slf4j.helpers.NOPMDCAdapter;import org.slf4j.helpers.Util;import org.slf4j.impl.StaticMDCBinder;import org.slf4j.spi.MDCAdapter;public class MDC &#123; static final String NULL_MDCA_URL = "http://www.slf4j.org/codes.html#null_MDCA"; static final String NO_STATIC_MDC_BINDER_URL = "http://www.slf4j.org/codes.html#no_static_mdc_binder"; static MDCAdapter mdcAdapter; private MDC() &#123; &#125; private static MDCAdapter bwCompatibleGetMDCAdapterFromBinder() throws NoClassDefFoundError &#123; try &#123; return StaticMDCBinder.getSingleton().getMDCA(); &#125; catch (NoSuchMethodError var1) &#123; return StaticMDCBinder.SINGLETON.getMDCA(); &#125; &#125; public static void put(String key, String val) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key parameter cannot be null"); &#125; else if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.put(key, val); &#125; &#125; public static MDC.MDCCloseable putCloseable(String key, String val) throws IllegalArgumentException &#123; put(key, val); return new MDC.MDCCloseable(key); &#125; public static String get(String key) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key parameter cannot be null"); &#125; else if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; return mdcAdapter.get(key); &#125; &#125; public static void remove(String key) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key parameter cannot be null"); &#125; else if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.remove(key); &#125; &#125; public static void clear() &#123; if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.clear(); &#125; &#125; public static Map&lt;String, String&gt; getCopyOfContextMap() &#123; if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; return mdcAdapter.getCopyOfContextMap(); &#125; &#125; public static void setContextMap(Map&lt;String, String&gt; contextMap) &#123; if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.setContextMap(contextMap); &#125; &#125; public static MDCAdapter getMDCAdapter() &#123; return mdcAdapter; &#125; static &#123; try &#123; mdcAdapter = bwCompatibleGetMDCAdapterFromBinder(); &#125; catch (NoClassDefFoundError var2) &#123; mdcAdapter = new NOPMDCAdapter(); String msg = var2.getMessage(); if (msg == null || !msg.contains("StaticMDCBinder")) &#123; throw var2; &#125; Util.report("Failed to load class \"org.slf4j.impl.StaticMDCBinder\"."); Util.report("Defaulting to no-operation MDCAdapter implementation."); Util.report("See http://www.slf4j.org/codes.html#no_static_mdc_binder for further details."); &#125; catch (Exception var3) &#123; Util.report("MDC binding unsuccessful.", var3); &#125; &#125; public static class MDCCloseable implements Closeable &#123; private final String key; private MDCCloseable(String key) &#123; this.key = key; &#125; public void close() &#123; MDC.remove(this.key); &#125; &#125;&#125; MDC中提供的全是静态方法，实现的核心是MDCAdapter，从命名方式，我们不难理解，这是适配器，这也是SLF4J的核心，提供适配器，具体的实现有Log4j或者LogBack。12345678910111213141516171819202122//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.slf4j.spi;import java.util.Map;public interface MDCAdapter &#123; void put(String var1, String var2); String get(String var1); void remove(String var1); void clear(); Map&lt;String, String&gt; getCopyOfContextMap(); void setContextMap(Map&lt;String, String&gt; var1);&#125; 我们使用的Logback，其中对MDCAdapter接口有具体的实现类LogbackMDCAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package ch.qos.logback.classic.util;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.Set;import org.slf4j.spi.MDCAdapter;public class LogbackMDCAdapter implements MDCAdapter &#123; final ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = new ThreadLocal(); private static final int WRITE_OPERATION = 1; private static final int MAP_COPY_OPERATION = 2; final ThreadLocal&lt;Integer&gt; lastOperation = new ThreadLocal(); public LogbackMDCAdapter() &#123; &#125; private Integer getAndSetLastOperation(int op) &#123; Integer lastOp = (Integer)this.lastOperation.get(); this.lastOperation.set(op); return lastOp; &#125; private boolean wasLastOpReadOrNull(Integer lastOp) &#123; return lastOp == null || lastOp.intValue() == 2; &#125; private Map&lt;String, String&gt; duplicateAndInsertNewMap(Map&lt;String, String&gt; oldMap) &#123; Map&lt;String, String&gt; newMap = Collections.synchronizedMap(new HashMap()); if (oldMap != null) &#123; synchronized(oldMap) &#123; newMap.putAll(oldMap); &#125; &#125; this.copyOnThreadLocal.set(newMap); return newMap; &#125; public void put(String key, String val) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key cannot be null"); &#125; else &#123; Map&lt;String, String&gt; oldMap = (Map)this.copyOnThreadLocal.get(); Integer lastOp = this.getAndSetLastOperation(1); if (!this.wasLastOpReadOrNull(lastOp) &amp;&amp; oldMap != null) &#123; oldMap.put(key, val); &#125; else &#123; Map&lt;String, String&gt; newMap = this.duplicateAndInsertNewMap(oldMap); newMap.put(key, val); &#125; &#125; &#125; public void remove(String key) &#123; if (key != null) &#123; Map&lt;String, String&gt; oldMap = (Map)this.copyOnThreadLocal.get(); if (oldMap != null) &#123; Integer lastOp = this.getAndSetLastOperation(1); if (this.wasLastOpReadOrNull(lastOp)) &#123; Map&lt;String, String&gt; newMap = this.duplicateAndInsertNewMap(oldMap); newMap.remove(key); &#125; else &#123; oldMap.remove(key); &#125; &#125; &#125; &#125; public void clear() &#123; this.lastOperation.set(Integer.valueOf(1)); this.copyOnThreadLocal.remove(); &#125; public String get(String key) &#123; Map&lt;String, String&gt; map = (Map)this.copyOnThreadLocal.get(); return map != null &amp;&amp; key != null ? (String)map.get(key) : null; &#125; public Map&lt;String, String&gt; getPropertyMap() &#123; this.lastOperation.set(Integer.valueOf(2)); return (Map)this.copyOnThreadLocal.get(); &#125; public Set&lt;String&gt; getKeys() &#123; Map&lt;String, String&gt; map = this.getPropertyMap(); return map != null ? map.keySet() : null; &#125; public Map&lt;String, String&gt; getCopyOfContextMap() &#123; Map&lt;String, String&gt; hashMap = (Map)this.copyOnThreadLocal.get(); return hashMap == null ? null : new HashMap(hashMap); &#125; public void setContextMap(Map&lt;String, String&gt; contextMap) &#123; this.lastOperation.set(Integer.valueOf(1)); Map&lt;String, String&gt; newMap = Collections.synchronizedMap(new HashMap()); newMap.putAll(contextMap); this.copyOnThreadLocal.set(newMap); &#125;&#125; 从源码中看出，核心思想还是ThreadLocal1234final ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = new ThreadLocal();private static final int WRITE_OPERATION = 1;private static final int MAP_COPY_OPERATION = 2;final ThreadLocal&lt;Integer&gt; lastOperation = new ThreadLocal(); 定义了2个ThreadLocal，一个维护着Map，这就是我们在使用时自己定义的追踪数据，另一个ThreadLocal记录着该线程的操作记录，需要注意，在上面的代码中，write操作即put会去修改lastOperation，而get操作则不会。这样就保证了，只会在第一次写时复制。 MDC的使用定义全局拦截器 MDC的使用很简单，只需要调用put方法就行，MDC.put(“traceId”, “traceId”),再结合HandlerInterceptor的使用，可以在所有的请求中都加上日志追踪，就无需手动在每个请求中加了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.smart.server.interceptor;import org.slf4j.MDC;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import java.lang.reflect.Method;import java.util.UUID;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;/** * ClassName: TimeHandlerInterceptor &lt;br/&gt; Function: 方法执行时间拦截器. &lt;br/&gt; date: 2017年3月23日 下午8:46:58 * &lt;br/&gt; * * author gaowenming since JDK 1.8 */@Slf4jpublic class TimeHandlerInterceptor implements HandlerInterceptor &#123; // 当前时间戳 private ThreadLocal&lt;Long&gt; threadLocalTime = new ThreadLocal&lt;&gt;(); /** * controller 执行之前调用 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //日志追加traceId追踪 MDC.put("traceId", "traceId=" + UUID.randomUUID().toString().replace("-", "")); long startTime = System.currentTimeMillis(); threadLocalTime.set(startTime); return true; &#125; /** * controller 执行之后，且页面渲染之前调用 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); long endTime = System.currentTimeMillis(); long startTime = threadLocalTime.get(); long executeTime = endTime - startTime; log.info("[&#123;&#125;.&#123;&#125;] 执行耗时:&#123;&#125;ms", method.getDeclaringClass().getName(), method.getName(), executeTime); &#125; /** * 页面渲染之后调用，一般用于资源清理操作 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; MDC.clear(); &#125;&#125; 定义一个全局拦截器，拦截所有的Controller请求，在preHandle方法中，调用MDC.put(“traceId”, “traceId=” + UUID.randomUUID().toString().replace(“-“, “”));这样traceId就会被加到该请求所有的链路中，在afterCompletion方法中clear，确保本次请求完成后，MDC中的数据要清空。该拦截器中还加入了方法的执行时间统计，原理和MDC类似，使用ThreadLocal。 修改logback.xml文件 上面我们往MDC中put了traceId的key，再把这个key增加到logback.xml文件中即可12345&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;%date %level %X&#123;traceId&#125; [%thread] %logger&#123;50&#125;-[%line] %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; 配置完logback文件后，然后就可以正常打印了 1232017-12-30 10:48:53,986 INFO traceId=73eb01785cce4ce8812dd091b07c2ccd [http-nio-8000-exec-8] 2017-12-30 10:48:53,987 WARN traceId=73eb01785cce4ce8812dd091b07c2ccd [http-nio-8000-exec-8] 2017-12-30 10:48:53,988 ERROR traceId=73eb01785cce4ce8812dd091b07c2ccd [http-nio-8000-exec-8] 到此，MDC的使用就介绍完了，其实总结起来也挺简单的，核心就是ThreadLocal，配置也非常简单，但是功能确很强大，很大的方便了我们对日志的追踪。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>MDC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc全局异常处理]]></title>
    <url>%2F2017%2F12%2F28%2FSpringMvc%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理是开发中不可避免的，好的异常处理方式，能提高代码的可读性，使代码更简洁，本文就介绍下在开发Rest接口时，如何优雅的处理异常。 如何抛出异常 java中异常分为2类：预期异常和运行时异常RuntimeException，预期异常就是需要明确的捕获异常，比如文件读写时，需要捕获IOException。运行时异常，无法预知的异常，比如著名的NullPointException。那么我们在定义接口时，怎么定义异常呢？一个原则，就是尽量在调用的最上层处理。 比如一个调用连中，Http-&gt;Controller-&gt;Service-&gt;Dao-&gt;DB,Controller层负责和调用端的数据交互，一般都会包含请求的响应状态，成功还是失败，返回的数据，通常我们都会定义一个通用的返回体，包含Code，Msg，ResultData，Service层负责具体的业务逻辑，Dao层负责与DB的交互。 正常成功的请求，可以在Controller层定义，但是各种系统的异常情况怎么优雅的处理呢？答案就是抛出异常。我们定义好业务异常(BusinessException),定义好异常code和异常信息Msg，在业务出现异常的情况时，直接抛出异常信息，由Controller层统一处理，Service层只需要在遇到异常时，直接Throw就可以，这样既能阻止程序继续往下执行，也避免了代码中无限的return。 定义业务异常 上面介绍了业务异常通用类，主要包含异常代码，异常信息，具体的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BusinessException extends RuntimeException &#123; private static final long serialVersionUID = 1L; private BusinessErrorMsg businessErrorMsg; public BusinessException(BusinessErrorMsg businessErrorMsg) &#123; this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; this.businessErrorMsg = businessErrorMsg; &#125; public BusinessException() &#123; this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessException(BusinessErrorMsg businessErrorMsg, Throwable cause) &#123; this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; this.businessErrorMsg = businessErrorMsg; &#125; public BusinessException(String message, Throwable cause) &#123; super(message, cause); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessException(String message) &#123; super(message); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; protected BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessException(Throwable cause) &#123; super(cause); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessErrorMsg getBusinessErrorMsg() &#123; return this.businessErrorMsg; &#125; public void setBusinessErrorMsg(BusinessErrorMsg businessErrorMsg) &#123; this.businessErrorMsg = businessErrorMsg; &#125;&#125; 异常代码我们使用枚举的方式12345678910111213141516171819202122232425262728293031package com.smart.service.base;public enum BusinessErrorMsg &#123; SYSTEM_ERROR(Integer.valueOf(9999), "系统错误"), VALIDATION_TOKEN_NULL(Integer.valueOf(1000), "token is null"), VALIDATION_PARAM_ERROR(Integer.valueOf(1001), "参数错误"); private Integer errorCode = Integer.valueOf(9999); private String errorMessage = "系统错误"; private BusinessErrorMsg(Integer errorCode, String errorMessage) &#123; this.errorCode = errorCode; this.errorMessage = errorMessage; &#125; public Integer getErrorCode() &#123; return this.errorCode; &#125; public void setErrorCode(Integer errorCode) &#123; this.errorCode = errorCode; &#125; public String getErrorMessage() &#123; return this.errorMessage; &#125; public void setErrorMessage(String errorMessage) &#123; this.errorMessage = errorMessage; &#125;&#125; 使用枚举的好处就是比较直观，code和msg一一对应 全局异常处理异常定义好了，那怎么能优雅的捕获呢？SpringMvc提供了全局RestControllerAdvice，顾名思义，RestController的拦截器，使用这种方式，我们就不用在Controller层使用try/catch了，直接交给异常处理器就ok了，是不是很方便呢。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.smart.server.handler;import com.smart.server.base.BaseJsonResult;import com.smart.service.base.BusinessErrorMsg;import com.smart.service.base.BusinessException;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.Arrays;import java.util.Map;import javax.servlet.http.HttpServletRequest;import lombok.extern.slf4j.Slf4j;/** * 全局异常处理 * * 2017年4月28日 下午10:14:26 &lt;br/&gt; * * author gaowenming version since JDK 1.8 */@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123; /** * 系统异常 * * @author gaowenming param req param e return throws Exception since JDK 1.8 */ @ExceptionHandler(value = Exception.class) @ResponseBody public BaseJsonResult&lt;Object&gt; defaultExceptionHandler(HttpServletRequest req, Exception e) throws Exception &#123; log.error("&lt;-----------------系统响应异常-----------------&gt;", e); printMethodParameters(req); BaseJsonResult&lt;Object&gt; baseJsonResult = new BaseJsonResult&lt;&gt;(); baseJsonResult.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); baseJsonResult.setMsg("请求失败,请稍后重试！"); return baseJsonResult; &#125; /** * 业务异常 * * @author gaowenming param req param e return throws Exception since JDK 1.8 */ @ExceptionHandler(value = BusinessException.class) @ResponseBody public BaseJsonResult&lt;Object&gt; smartBusinessExceptionHandler(HttpServletRequest req, BusinessException e) throws Exception &#123; BaseJsonResult&lt;Object&gt; baseJsonResult = new BaseJsonResult&lt;&gt;(); BusinessErrorMsg businessErrorMsg = e.getBusinessErrorMsg(); log.warn("catch BusinessException,code:&#123;&#125;,message:&#123;&#125;", businessErrorMsg.getErrorCode(), businessErrorMsg.getErrorMessage()); printMethodParameters(req); baseJsonResult.setStatus(businessErrorMsg.getErrorCode()); baseJsonResult.setMsg(businessErrorMsg.getErrorMessage()); return baseJsonResult; &#125; /** * 记录方法的入参 */ private static void printMethodParameters(HttpServletRequest request) &#123; StringBuilder methodInfo = new StringBuilder(); methodInfo.append("url=").append(request.getServletPath()); methodInfo.append(" ;params= "); if (request.getQueryString() != null) &#123; methodInfo.append(request.getQueryString()).append(" - "); &#125; else &#123; Map&lt;String, String[]&gt; parameters = request.getParameterMap(); if (parameters.size() != 0) &#123; methodInfo.append(" ["); &#125; for (Map.Entry&lt;String, String[]&gt; entry : parameters.entrySet()) &#123; String key = entry.getKey(); Object value = entry.getValue(); String message = ""; if (value.getClass().isArray()) &#123; Object[] args = (Object[]) value; message = " " + key + "=" + Arrays.toString(args) + " "; &#125; else &#123; message = key + "=" + String.valueOf(value) + " "; &#125; methodInfo.append(message); &#125; if (parameters.size() != 0) &#123; methodInfo.append("]"); &#125; &#125; log.info(methodInfo.toString()); &#125;&#125; 定义GlobalExceptionHandler，加上@RestControllerAdvice注解，这样就表示拦截Controller所有的异常情况了，我们可以使用@ExceptionHandler注解，处理不同类型的异常。推荐大家把异常发生时的入参都打印出来，这样能够方便我们在出现异常时快速的定位问题。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于注解的Token校验方案]]></title>
    <url>%2F2017%2F12%2F26%2F%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Token%E6%A0%A1%E9%AA%8C%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在后端开发中，通常需要对接口做权限校验，校验用户是否需要登录，是否需要认证等等，本文就来介绍下如何通过注解的方式来对Token做认证 注解定义 其实说到用户认证，大家脑海中肯定会想到拦截器（Interceptor）和过滤器（Filter），那么怎样才能更灵活的实现呢？注解毫无疑问就派上用场了。 首先定义注解：1234567891011121314151617package com.smart.server.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * token注解，可用于类、方法中，拦截token验证 * * Created by gaowenming on 2017/6/15. */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface TokenValidation &#123; String name() default "";&#125; 定义一个注解TokenValidation，Target的作用范围是TYPE和METHOD，也就是可以在Class类上，也可以在方法上，如果是在类上使用注解，表示该类所有的方法都需要进行Token的校验，如果在方法上，表示该方法需要进行认证。 注解实现 注解定义好了,我们基于AOP的方式，对注解进行拦截123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.smart.server.util.Constants;import com.smart.service.base.BusinessErrorMsg;import com.smart.service.base.BusinessException;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import lombok.extern.slf4j.Slf4j;/** * Created by gaowenming on 2017/6/15. */@Aspect@Component@Slf4jpublic class TokenValidationInterceptor &#123; //注解在类上面@within @Pointcut("@within(com.smart.server.annotation.TokenValidation)") public void pointcut() &#123; &#125; @Before("pointcut()") public void tokenValidationType(JoinPoint point) throws Throwable &#123; commonTokenValidation(point); &#125; //注解在方法上面@annotation @Pointcut("@annotation(com.smart.server.annotation.TokenValidation)") public void pointcutMethod() &#123; &#125; @Before("pointcutMethod()") public void tokenValidationMethod(JoinPoint point) throws Throwable &#123; commonTokenValidation(point); &#125; //公共的校验 public static void commonTokenValidation(JoinPoint point) throws Throwable &#123; HttpServletRequest request; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; request = sra.getRequest(); String url = request.getServletPath(); String token = request.getHeader(Constants.TOKEN_NAME); log.info("TokenHandlerInterceptor----- url:&#123;&#125;,token:&#123;&#125; ", url, token); if (StringUtils.isEmpty(token)) &#123; throw new BusinessException(BusinessErrorMsg.VALIDATION_TOKEN_NULL); &#125; //校验token是否过期和正确 //TODO &#125;&#125; 上面的实现，做个简单的说明，首先我们约定好，token封装在Http请求的Header中，拦截器上中先从Header中获取token的值，然后判断token是否为空，如果不为空，还需要判断token是否过期，是否正确。在实际项目中，用户登录后，服务端会根据一定的算法计算出token的值，然后把该token的值放入Redis中，并设置有效期，这样就很方便的处理过期的问题。 注解使用经过上面的2步，就可以在我们定义的Controller中使用我们定义的注解了12345678910111213141516171819202122232425262728293031323334353637383940414243package com.smart.server.controller;import com.smart.model.Dic;import com.smart.server.annotation.TokenValidation;import com.smart.server.base.BaseController;import com.smart.server.base.BaseJsonResult;import com.smart.service.IDicService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import io.swagger.annotations.Api;import lombok.extern.slf4j.Slf4j;@RestController@RequestMapping("api/dic/")@Api@Slf4jpublic class DicController extends BaseController &#123; @Autowired private IDicService dicService; @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) public BaseJsonResult&lt;Dic&gt; getDic(@PathVariable Integer id) throws Exception &#123; log.info("getDic......."); Dic dic = dicService.get(id); return successResult(dic); &#125; @RequestMapping(value = "/addDic", method = RequestMethod.POST) @TokenValidation public BaseJsonResult addDic(@RequestBody Dic dic) throws Exception &#123; log.info("addDic......."); dicService.save(dic); return successNullDataResult(); &#125;&#125; 是不是很方便，get操作不需要校验，就无需增加注解，在add操作中，增加token校验，加上注解即可。 为什么用注解 使用注解的方式，你会发现非常灵活，类和方法可以自己灵活设置，处理逻辑使用AOP的方式统一处理。其实还有其他的一些使用场景，比如有些接口返回值需要加密返回，也可以使用类似的注解方式实现。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis解决定时任务在分布式环境单节点执行]]></title>
    <url>%2F2017%2F12%2F24%2FRedis%E8%A7%A3%E5%86%B3%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E5%8D%95%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[定时任务，在日常开发中是经常用到的，在分布式环境中，定时任务的执行往往需要控制多节点同时执行的问题，比如可以借助Quartz，或者分布式锁，本文提供另一种解决方式，也是借助Redis。 实现方式 在Redis中，提供了自增和增减的相关命令，来保证计数的原子性 incr 递增1并返回递增后的结果；incrby 根据指定值做递增或递减操作并返回递增或递减后的结果(incrby递增或递减取决于传入值的正负)decr 递减1并返回递减后的结果；decrby 根据指定值做递增或递减操作并返回递增或递减后的结果(decrby递增或递减取决于传入值的正负) 了解了上面几个命令之后，在来说通过计数器来控制并发执行，应该就很容易理解了直接上代码吧：1234567long jobKeyValue = redisKeyValueResolver.increment(ExdataConstants.JOB_KEY);LOGGER.debug("jobKeyIncrementAfterValue:&#123;&#125;", jobKeyValue); if (jobKeyValue == 1) &#123; //一秒失效 redisKeyValueResolver.expireKey(ExdataConstants.JOB_KEY, 1); //业务逻辑。。。 &#125; 上面一段代码，首先定义一个key，当定时任务触发时，多个节点同时执行incr自增操作,第一个执行自增的节点的值就是1，其他的节点就是2、3、4…根据自增后的值来控制定时任务的执行，也就可以有效的控制只执行一次了。 当然还是需要注意，一定要在if语句块最前面执行expire操作，因为执行业务逻辑需要时间，更有可能出现异常，所以在最前面设置过期时间，保证了下次定时任务执行时，key已失效。 不需要使用较重的分布式锁，巧妙的运用了Redis的原子操作，这样是的实现方式是不是更简单呢?]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j的debug日志引起的线上故障]]></title>
    <url>%2F2017%2F12%2F22%2FLog4j%E7%9A%84debug%E6%97%A5%E5%BF%97%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%2F</url>
    <content type="text"><![CDATA[前天下午，运维突然在微信群里说系统流量下跌了，报警邮件也马上来了，都是api接口的time out，查看各种监控工具，zabbix，oneapm，es集群，除了发现流量有下跌，没有别的异常情况。 错误现象 入口流量没有明显增加查看了流量监控，入口流量并没有出现爆发式的增长，很平稳，毕竟我们的流量高峰是在上午，下午3点很难出现高峰 内存、CPU没有明显波动查看系统的运行状态，内存、CPU都没有出现大的波动，说明并没有出现大的计算任务，如果有计算型的任务，会消耗大量的内存和CPU资源 线程数上升迅猛看监控，配置的Tomcat的线程池满了，直接导致了系统的请求超时。[图片] 异常原因分析 既然已经确认是由于线程池的堆积，造成系统的调用超时，那么为什么会突然之间线程池暴涨呢？原因竟然是由于一个同事开启了线上的debug日志跟踪一个问题，持续时间大概20分钟，那么问题来了，log4j开启debug日志，为什么会导致线程池暴涨，造成系统崩溃呢？ 由于log4j同步打日志，当debug日志过多时，频繁的写磁盘文件，api请求的耗时就会增加，那么该api占用的线程的时间就会变长，当占用时间过长，导致线程池不够时，就会出现等待的情况，持续时间一长，等待的线程越来越多，那么就会出现time out了 如何解决 规范日志的打印日志打印不是越多越好，其实只要关键位置的日志往往就可以，比如方法的入口和出口，逻辑的分叉，try/catch的异常日志 异常信息的拼装往往debug的时候，打印日志都是很详细的，比如某个对象的完整信息，Http的完整响应等，这些信息都是比较大的，这时候如果用log.debug(Json.toJSONString(user));也许你觉得这么写也没有什么问题啊，其实不然，虽然如果你设置info级别，这个debug日志是不会打印，但是它会执行Json的转换，这其实也是损耗性能的，系统的性能往往就是细节地方不注意，累计多了，就会出现瓶颈。这时，可以使用级别判断来解决这个问题 if(log.isDebugEnable) { LOG.debug(“params = {}”, JSON.toJSONString(user)); } 可以采用logback、log4j2来替换log4j。log4j2已经发行了稳定版本，logback是基于slf4j的门面实现，性能都比log4j高不少]]></content>
      <categories>
        <category>故障分析</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装Docker]]></title>
    <url>%2F2017%2F12%2F05%2FCentos7%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"><![CDATA[在工作中,总是避免不了搭建各种开发环境，配置各种组件的环境变量，如果你厌倦了以往的方式，你可以尝试使用Docker，本文就从Docker的安装开始。 安装说明 Docker支持以下的CentOS版本：CentOS 7 (64-bit)CentOS 6.5 (64-bit) 或更高的版本前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 yum安装docker 1.使用root权限登陆系统。 2.更新系统包到最新。 yum -y update 3、安装docker yum -y install docker 4、启动docker服务 systemctl start docker.service 5、创建开机启动Docker服务 systemctl enable docker.service 6、查看Docker版本号 docker version 7、运行hello-world docker run hello-world 后续后续的组件，我会尽量用Docker的方式来处理，这样既方便快捷，也完美的解决了一台机器中安装某个服务的多个版本，比如es，redis，后面也会在使用中总结更多的用法。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat的线程安全问题]]></title>
    <url>%2F2017%2F11%2F26%2FSimpleDateFormat%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat在进行日期格式转换时用的很多，但是 DateFormat 和 SimpleDateFormat 类不都是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题 多线程测试12345678910111213141516 * &lt;p&gt; * Date formats are not synchronized. * It is recommended to create separate format instances for each thread. * If multiple threads access a format concurrently, it must be synchronized * externally. * * @see &lt;a href="http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html"&gt;Java Tutorial&lt;/a&gt; * @see java.util.Calendar * @see java.util.TimeZone * @see DateFormat * @see DateFormatSymbols * @author Mark Davis, Chen-Lieh Huang, Alan Liu */public class SimpleDateFormat extends DateFormat &#123;...................｝ 在注视中，明确说明If multiple threads access a format concurrently, it must be synchronized测试代码：12345678910111213141516171819202122public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; 上面的测试方法在多线程下会出现如下异常：123456789101112131415161718192021222324252627282930313233343536Exception in thread "Thread-1" Exception in thread "Thread-3" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)Exception in thread "Thread-8" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2088)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745) 根本原因SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。 在format方法里，有这样一段代码：12private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // Convert input date to time field list calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法： 线程1调用format方法，改变了calendar这个字段。 中断来了。 线程2开始执行，它也改变了calendar。 又中断了。 线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。 分析一下format的实现，我们不难发现，用到成员变量calendar，唯一的好处，就是在调用subFormat时，少了一个参数，却带来了这许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。 这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。 解决办法 每次需要的时候都创建一个新的实例 使用同步：同步SimpleDateFormat对象 使用common-lang中的api中的FastDateFormat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.CountDownLatch;import org.apache.commons.lang3.time.FastDateFormat;import org.junit.Test;/** * 测试时间处理类的线程安全问题 * @Description * @author gaowenming */public class SimpleDateFormatTest &#123; public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; @Test public void testCommonLang() &#123; //CommonLang第三方jar包实现 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; FastDateFormat fdf = FastDateFormat.getInstance(PATTEN); System.out.println(fdf.format(new Date())); Date date = fdf.parse("2013-05-24 06:02:20"); System.out.println(date); countDownLatch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; try &#123; //等待100个线程都执行完 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
</search>
