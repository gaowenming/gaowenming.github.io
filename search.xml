<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SimpleDateFormat的线程安全问题]]></title>
    <url>%2F2017%2F11%2F26%2FSimpleDateFormat%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat在进行日期格式转换时用的很多，但是 DateFormat 和 SimpleDateFormat 类不都是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题 多线程测试12345678910111213141516 * &lt;p&gt; * Date formats are not synchronized. * It is recommended to create separate format instances for each thread. * If multiple threads access a format concurrently, it must be synchronized * externally. * * @see &lt;a href="http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html"&gt;Java Tutorial&lt;/a&gt; * @see java.util.Calendar * @see java.util.TimeZone * @see DateFormat * @see DateFormatSymbols * @author Mark Davis, Chen-Lieh Huang, Alan Liu */public class SimpleDateFormat extends DateFormat &#123;...................｝ 在注视中，明确说明If multiple threads access a format concurrently, it must be synchronized测试代码：12345678910111213141516171819202122public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; 上面的测试方法在多线程下会出现如下异常：123456789101112131415161718192021222324252627282930313233343536Exception in thread "Thread-1" Exception in thread "Thread-3" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)Exception in thread "Thread-8" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2088)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745) 根本原因SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。 在format方法里，有这样一段代码：12private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // Convert input date to time field list calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法： 线程1调用format方法，改变了calendar这个字段。 中断来了。 线程2开始执行，它也改变了calendar。 又中断了。 线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。 分析一下format的实现，我们不难发现，用到成员变量calendar，唯一的好处，就是在调用subFormat时，少了一个参数，却带来了这许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。 这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。 解决办法 每次需要的时候都创建一个新的实例 使用同步：同步SimpleDateFormat对象 使用common-lang中的api中的FastDateFormat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.CountDownLatch;import org.apache.commons.lang3.time.FastDateFormat;import org.junit.Test;/** * 测试时间处理类的线程安全问题 * @Description * @author gaowenming */public class SimpleDateFormatTest &#123; public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; @Test public void testCommonLang() &#123; //CommonLang第三方jar包实现 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; FastDateFormat fdf = FastDateFormat.getInstance(PATTEN); System.out.println(fdf.format(new Date())); Date date = fdf.parse("2013-05-24 06:02:20"); System.out.println(date); countDownLatch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; try &#123; //等待100个线程都执行完 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
</search>
