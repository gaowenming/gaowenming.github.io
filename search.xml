<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot中Properties文件的解析]]></title>
    <url>%2F2018%2F01%2F21%2FSpring-Boot%E4%B8%ADProperties%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[项目中经常会把一些公共的配置放在Properties文件中，然后通过一些方法读取Properties文件的属性名和对应的值，通常都是解析成Map格式，在Spring Boot中，还提供了另一种更灵活的方式：自定义类，和Properties文件一一对应。 新建Properties文件新建一个文件，存放一些公共的配置12345678#1、组件集成之外的自定义配置，最好和部署环境无关的，和环境相关的，还是配置在application文件中#2、所有的key都加上smart前缀,防止和application中的key冲突#3、当前key/value的解析在SmartConfigProperties文件中，新增的key需要再类中声明即可smart.username=gaowenmingsmart.secretKey=123456789smart.id=1000smart.names=zhangsan,lisismart.weight=60.5 在上面的文件中，我们都加上smart前缀，这样更好的避免和别的配置重名 定义配置的公共类1234567891011121314151617181920import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import lombok.Data;/** * 业务配置 Author: gaowenming Description: Date: Created in 11:59 2017/7/15. */@Configuration@PropertySource("classpath:config.properties")//注意路径@ConfigurationProperties(prefix = "smart")@Datapublic class SmartConfigProperties &#123; private String username; private String secretKey; private int id; private String[] names; private float weight;&#125; Spring Boot中，可以支持Properties文件到类的类型转换，常规的类型和数组，List都支持，这样避免了我们自己解析后再强制类型转换，实现方式更优雅。 使用配置这种方式很好的把所有的配置都集中到一起，如果配置太多，我们也可以分多个类，避免一个类中太臃肿。使用起来也是很方便，直接把配置类注入到使用的地方即可12345678910111213141516171819202122@RestController@RequestMapping("api/test/")@Api@Slf4jpublic class TestController extends BaseController &#123; @Resource private SmartConfigProperties smartConfigProperties; @RequestMapping(value = "getConfigValue", method = RequestMethod.GET) public BaseJsonResult getConfigValue() throws Exception &#123; String[] names = smartConfigProperties.getNames(); for (String str : names) &#123; log.info(str); &#125; int id = smartConfigProperties.getId(); String username = smartConfigProperties.getUsername(); float weight = smartConfigProperties.getWeight(); log.info("names:&#123;&#125;,id:&#123;&#125;,username:&#123;&#125;,weight:&#123;&#125;", names, id, username, weight); return successNullDataResult(); &#125;&#125; 使用这种方式解析Properties文件,首先不需要我们自己在强制转换数据类型，也使配置都集中管理，确实是给我们的代码带来更多的可读性，虽然功能简单，但是作用却很大。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用@Scheduled执行定时任务]]></title>
    <url>%2F2018%2F01%2F20%2FSpring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8-Scheduled%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[日常工作中，有一些需要定时执行的任务，实现方式有Quartz，SpringTask，Quartz结合数据库使用，可以实现多节点的单实例执行。Spring Boot中也提供定时执行的解决方案@Scheduled。 创建任务 Spring Boot中要想使用@Scheduled，需要在Application中添加@EnableScheduling 1234567891011@SpringBootApplication@EnableTransactionManagement // 开启事务@ComponentScan("com.smart") // 扫描service和controller@MapperScan("com.smart.mapper") // 扫描mapper@EnableAspectJAutoProxy//允许动态代理@EnableSchedulingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 定义任务 12345678@Service@Slf4jpublic class ScheduledTiming &#123;true@Scheduled(fixedRate = 1000)truepublic void myTask() throws Exception &#123;truetruelog.info("...........定时任务开始执行........");true&#125;&#125; 上面的定时任务，只需要在方法上添加@Scheduled注解，就这么简单，就实现了定时执行，任务的执行周期也可以自定义，固定周期和表达式都支持，详细的可以参考Scheduled的源码1234567891011121314151617181920212223242526272829303132333435//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.scheduling.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(Schedules.class)public @interface Scheduled &#123; String cron() default ""; String zone() default ""; long fixedDelay() default -1L; String fixedDelayString() default ""; long fixedRate() default -1L; String fixedRateString() default ""; long initialDelay() default -1L; String initialDelayString() default "";&#125; 直接把定时任务的声明和执行周期通过注解的方式实现，的确方便了很多，也省去配置，传统的实现方式往往需要在xml文件中配置task以及task的trigger，Spring Boot的思想是约定由于配置，所以很多地方都是尽量不用配置的方式。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Scheduled</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用@Async实现异步调用]]></title>
    <url>%2F2018%2F01%2F20%2FSpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8%40Async%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在实际项目中，经常需要用到异步处理，大部分情况我们都会使用定义一个线程（Thread），通过ExecutorService来调度，这样实现没有任何问题，那么有没有更简单方便的实现呢？Spring中提供了@Async注解，来简化异步操作。 @Async的定义123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Async &#123; String value() default "";&#125; Async的Target包含Method和Type，也就是可以定义在类或者方法上，那么@Async的工作原理是什么样的呢? spring在扫描bean的时候会扫描方法上是否包含@async的注解，如果包含的，spring会为这个bean动态的生成一个子类，我们称之为代理类,代理类继承我们所写的bean的，然后把代理类注入进来，那此时，在执行此方法的时候，会到代理类中，代理类判断了此方法需要异步执行，就不会调用父类(我们原本写的bean)的对应方法。spring自己维护了一个队列，他会把需要执行的方法，放入队列中，等待线程池去读取这个队列，完成方法的执行，从而完成了异步的功能。我们可以关注到再配置task的时候，是有参数让我们配置线程池的数量的。因为这种实现方法，所以在同一个类中的方法调用，添加@async注解是失效的！，原因是当你在同一个类中的时候，方法调用是在类体内执行的，spring无法截获这个方法调用。 @Async的使用 使用@Async很简单，只需要在方法上加上注解即可，方法可以定义2种，有返回值和没有返回值得，有的时候我们还是希望获取该异步任务的返回值123456789101112131415161718192021222324252627282930313233343536373839import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import org.springframework.stereotype.Component;import java.util.Random;import java.util.concurrent.Future;import lombok.extern.slf4j.Slf4j;/** * 基于Async注解的异步任务，需要开启@EnableAsync * Author: gaowenming * Description: * Date: Created in 20:49 2017/7/2. */@Component@Slf4jpublic class AsyncTask &#123; private static Random random = new Random(); @Async public Future&lt;String&gt; task1() throws Exception &#123; System.out.println("开始做任务一"); long start = System.currentTimeMillis(); Thread.sleep(random.nextInt(10000)); long end = System.currentTimeMillis(); System.out.println("完成任务一，耗时：" + (end - start) + "毫秒"); return new AsyncResult&lt;&gt;("任务一完成"); &#125; @Async("smartExecutor") public void taskAsync1() throws Exception &#123; Thread.sleep(1000); for (int i = 0; i &lt; 10; i++) &#123; log.info("##########################" + i); &#125; &#125;&#125; 上面的实例中，我们定义了2个方法，在执行异步操作时，我们还可以指定线程池，@Async(“smartExecutor”)，smartExecutor是我们定义的线程池123456789101112131415161718192021222324252627282930313233/** * 定义线程池 */@Configuration@EnableAsyncpublic class ThreadExecutorConfig &#123; /** * Set the ThreadPoolExecutor's core pool size. */ private static final int corePoolSize = 10; /** * Set the ThreadPoolExecutor's maximum pool size. */ private static final int maxPoolSize = 200; /** * Set the capacity for the ThreadPoolExecutor's BlockingQueue. */ private static final int queueCapacity = 10; @Bean public Executor smartExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.setMaxPoolSize(maxPoolSize); executor.setQueueCapacity(queueCapacity); executor.setThreadNamePrefix("smartExecutor-"); executor.initialize(); return executor; &#125;&#125; 这里需要注意的是，在SpringBoot中，要启用@Async注解，还需要在config上加上@EnableAsync注解，表示启用@Async注解 线程池和异步方法定义好之后，接下来就是调用，我们可以和普通方法一样12345678910111213141516171819@RestController@RequestMapping("api/task/")@Slf4j@Apipublic class TaskController extends BaseController &#123; @Autowired private AsyncTask asyncTask; @RequestMapping(value = "/async", method = RequestMethod.GET) public BaseJsonResult task1() throws Exception &#123; log.info("test async................"); asyncTask.task1(); asyncTask.taskAsync1(); return successNullDataResult(); &#125;&#125; 是不是很方便，在需要异步操作的时候，终于不用再自己创建Thread了，而且也可以在方法上加上参数，和普通方法一样，很大的增加了代码的可读性。 注意的问题 在实际的开发中，其实我们可以把需要异步操作的方法定义公共的类中，也可以给不同的操作指定不同的线程池，那么如果在异步操作中发生异常该如何处理呢？Spring提供了AsyncUncaughtExceptionHandler这个Handler来处理，我们可以在发生异常的时候，根据不同操作的定义不同的处理机制。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Dubbo接口授权]]></title>
    <url>%2F2018%2F01%2F19%2F%E8%81%8A%E8%81%8ADubbo%E6%8E%A5%E5%8F%A3%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[上一篇博客讲了如何使用Dubbo的Filter实现日志追踪，其实Filter的功能有很多，今天讲讲如何使用Filter实现Dubbo的接口授权 Dubbo本身是没有授权机制的，所以需要我们自己实现，具体的实现方案如下： 授权的粒度，主要有如下几种：1、全部接口2、部分接口3、单个接口 授权服务本身的稳定性也是十分重要的，不要因为授权服务的不可用造成正常业务的瘫痪。伪代码如下：123456789101112public class AuthFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; if (success) &#123; return invoker.invoke(invocation); &#125; else &#123; // TODO 错误处理 &#125; &#125;&#125; 原理也很简单，在执行invoke之前先对consumer的请求做校验，首先dubbo调用时，公共参数都是可以获取的，比如方法名称，consumer端的名称等，当然还可以通过下发appId的方式，来区分调用端123456789public class ConsumerContextFilter implements Filter &#123; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; // 设置appId RpcContext.getContext().setAttachment("appId", appId); // 执行接口 return invoker.invoke(invocation); &#125;&#125; consumer端把自身的appid传到provider，provider会根据appid来区分不同调用的权限 Dubbo的Filter用处确实很多，而且使用也很方便，通过2篇文章讲解了日志和权限的应用，能够在不侵入业务的情况下完成既定的功能，非常灵活。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Dubbo的分布式日志追踪]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%9F%BA%E4%BA%8EDubbo%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[之前讲过单系统中的日志追踪，现在系统设计都是往服务化的方向发展，一个大型项目被拆分成多个服务，服务之间互相调用。拆分的服务越多，服务之间的关系越复杂，日志的追踪就更加困难。那么RPC之间怎么做到日志追踪呢，本文就介绍下基于Dubbo的日志追踪。 Dubbo的Filter接口我们需要先介绍下Dubbo的Filter接口12345678package com.alibaba.dubbo.rpc;import com.alibaba.dubbo.common.extension.SPI;@SPIpublic interface Filter &#123; Result invoke(Invoker&lt;?&gt; var1, Invocation var2) throws RpcException;&#125; 接口的定义很简单，只有一个invoke方法，由此就可以得到我们的实现思路，在Dubbo的调用端生成traceId，在调用的时候把该traceId传递到服务端，服务端拿到这个traceId，用该traceId作为本次调用的追踪id，Dubbo也提供了RpcContext类，用于Consumer到Provider的参数传递12345678910111213141516public class RpcContext &#123; private static final ThreadLocal&lt;RpcContext&gt; LOCAL = new ThreadLocal&lt;RpcContext&gt;() &#123; protected RpcContext initialValue() &#123; return new RpcContext(); &#125; &#125;; private Future&lt;?&gt; future; private List&lt;URL&gt; urls; private URL url; private String methodName; private Class&lt;?&gt;[] parameterTypes; private Object[] arguments; private InetSocketAddress localAddress; private InetSocketAddress remoteAddress; private final Map&lt;String, String&gt; attachments = new HashMap(); private final Map&lt;String, Object&gt; values = new HashMap(); RpcContext中有attachments属性，参数可以通过key-value的形式传递 Consumer端生成traceId12345678910111213public class TraceFilter implements Filter &#123; private static Logger LOGGER = LoggerFactory.getLogger(TraceFilter.class); @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; RpcContext context = RpcContext.getContext(); String chTraceId = MDC.get("traceID"); LOGGER.debug("chTraceId=&#123;&#125;", chTraceId); context.setAttachment("chTraceId", chTraceId); return invoker.invoke(invocation); &#125;&#125; 调用端发起请求前，往RpcContext中加入我们自己定义的traceId Provider端接收traceId12345678910111213141516171819public class TraceFilter implements Filter &#123; private static Logger LOGGER = LoggerFactory.getLogger(TraceFilter.class); @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; RpcContext context = RpcContext.getContext(); String chTraceId = context.getAttachment("chTraceId") + "&amp;client=" + context.getRemoteAddressString(); LOGGER.debug("chTraceId=&#123;&#125;", chTraceId); if (StringUtils.isNotEmpty(chTraceId)) &#123; MDC.put("traceID", chTraceId); &#125; Result result = invoker.invoke(invocation); if (StringUtils.isNotEmpty(chTraceId)) &#123; MDC.clear(); &#125; return result; &#125;&#125; 服务提供端收到traceId，然后使用该id做为后续整个接口链路的日志追踪id实现其实很简单，只需要分别在服务的2端实现Filter接口，使用RpcContext发送和接收参数最后还需在resource目录下定义自己的Filter，新建META-INF\dubbo目录，定义一个文件，文件名：com.alibaba.dubbo.rpc.Filter，里面增加一行自己定义的Filter，内容如下：traceFilter=com.wlqq.ms.filter.TraceFilter详细的配置可以参考Dubbo的官方说明文档：http://dubbo.io/books/dubbo-user-book/demos/attachment.html 总结分布式链路追踪其实是一个复杂的项目，本文只是一个简单的实现，Google提出了dapper论文，Twitter开源的Zipkin，后面会介绍下Zipkin的使用，也打算在项目中引入Zipkin，毕竟现在这种实现还是无法满足复杂的场景。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MDC追踪系统日志]]></title>
    <url>%2F2017%2F12%2F30%2F%E4%BD%BF%E7%94%A8MDC%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[在系统开发中，日志必不可少，前段时间我们还因为在线上开启Debug而造成系统故障，所以日志的处理应该让我们更加重视。在线上系统，日志很多，接口之间的日志错乱交替的打印，大大的影响了我们对日志的跟踪，我们要想跟踪一次请求的完整日志，好像都只能通过时间、线程名等信息，但是也无法精确的找出。MDC的出现，完美的解决了这个棘手的问题。 什么是MDC MDC ( Mapped Diagnostic Contexts )，是SLF4J中提供的一个类，专门用来跟踪请求链路的日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.slf4j;import java.io.Closeable;import java.util.Map;import org.slf4j.helpers.NOPMDCAdapter;import org.slf4j.helpers.Util;import org.slf4j.impl.StaticMDCBinder;import org.slf4j.spi.MDCAdapter;public class MDC &#123; static final String NULL_MDCA_URL = "http://www.slf4j.org/codes.html#null_MDCA"; static final String NO_STATIC_MDC_BINDER_URL = "http://www.slf4j.org/codes.html#no_static_mdc_binder"; static MDCAdapter mdcAdapter; private MDC() &#123; &#125; private static MDCAdapter bwCompatibleGetMDCAdapterFromBinder() throws NoClassDefFoundError &#123; try &#123; return StaticMDCBinder.getSingleton().getMDCA(); &#125; catch (NoSuchMethodError var1) &#123; return StaticMDCBinder.SINGLETON.getMDCA(); &#125; &#125; public static void put(String key, String val) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key parameter cannot be null"); &#125; else if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.put(key, val); &#125; &#125; public static MDC.MDCCloseable putCloseable(String key, String val) throws IllegalArgumentException &#123; put(key, val); return new MDC.MDCCloseable(key); &#125; public static String get(String key) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key parameter cannot be null"); &#125; else if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; return mdcAdapter.get(key); &#125; &#125; public static void remove(String key) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key parameter cannot be null"); &#125; else if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.remove(key); &#125; &#125; public static void clear() &#123; if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.clear(); &#125; &#125; public static Map&lt;String, String&gt; getCopyOfContextMap() &#123; if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; return mdcAdapter.getCopyOfContextMap(); &#125; &#125; public static void setContextMap(Map&lt;String, String&gt; contextMap) &#123; if (mdcAdapter == null) &#123; throw new IllegalStateException("MDCAdapter cannot be null. See also http://www.slf4j.org/codes.html#null_MDCA"); &#125; else &#123; mdcAdapter.setContextMap(contextMap); &#125; &#125; public static MDCAdapter getMDCAdapter() &#123; return mdcAdapter; &#125; static &#123; try &#123; mdcAdapter = bwCompatibleGetMDCAdapterFromBinder(); &#125; catch (NoClassDefFoundError var2) &#123; mdcAdapter = new NOPMDCAdapter(); String msg = var2.getMessage(); if (msg == null || !msg.contains("StaticMDCBinder")) &#123; throw var2; &#125; Util.report("Failed to load class \"org.slf4j.impl.StaticMDCBinder\"."); Util.report("Defaulting to no-operation MDCAdapter implementation."); Util.report("See http://www.slf4j.org/codes.html#no_static_mdc_binder for further details."); &#125; catch (Exception var3) &#123; Util.report("MDC binding unsuccessful.", var3); &#125; &#125; public static class MDCCloseable implements Closeable &#123; private final String key; private MDCCloseable(String key) &#123; this.key = key; &#125; public void close() &#123; MDC.remove(this.key); &#125; &#125;&#125; MDC中提供的全是静态方法，实现的核心是MDCAdapter，从命名方式，我们不难理解，这是适配器，这也是SLF4J的核心，提供适配器，具体的实现有Log4j或者LogBack。12345678910111213141516171819202122//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.slf4j.spi;import java.util.Map;public interface MDCAdapter &#123; void put(String var1, String var2); String get(String var1); void remove(String var1); void clear(); Map&lt;String, String&gt; getCopyOfContextMap(); void setContextMap(Map&lt;String, String&gt; var1);&#125; 我们使用的Logback，其中对MDCAdapter接口有具体的实现类LogbackMDCAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package ch.qos.logback.classic.util;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.Set;import org.slf4j.spi.MDCAdapter;public class LogbackMDCAdapter implements MDCAdapter &#123; final ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = new ThreadLocal(); private static final int WRITE_OPERATION = 1; private static final int MAP_COPY_OPERATION = 2; final ThreadLocal&lt;Integer&gt; lastOperation = new ThreadLocal(); public LogbackMDCAdapter() &#123; &#125; private Integer getAndSetLastOperation(int op) &#123; Integer lastOp = (Integer)this.lastOperation.get(); this.lastOperation.set(op); return lastOp; &#125; private boolean wasLastOpReadOrNull(Integer lastOp) &#123; return lastOp == null || lastOp.intValue() == 2; &#125; private Map&lt;String, String&gt; duplicateAndInsertNewMap(Map&lt;String, String&gt; oldMap) &#123; Map&lt;String, String&gt; newMap = Collections.synchronizedMap(new HashMap()); if (oldMap != null) &#123; synchronized(oldMap) &#123; newMap.putAll(oldMap); &#125; &#125; this.copyOnThreadLocal.set(newMap); return newMap; &#125; public void put(String key, String val) throws IllegalArgumentException &#123; if (key == null) &#123; throw new IllegalArgumentException("key cannot be null"); &#125; else &#123; Map&lt;String, String&gt; oldMap = (Map)this.copyOnThreadLocal.get(); Integer lastOp = this.getAndSetLastOperation(1); if (!this.wasLastOpReadOrNull(lastOp) &amp;&amp; oldMap != null) &#123; oldMap.put(key, val); &#125; else &#123; Map&lt;String, String&gt; newMap = this.duplicateAndInsertNewMap(oldMap); newMap.put(key, val); &#125; &#125; &#125; public void remove(String key) &#123; if (key != null) &#123; Map&lt;String, String&gt; oldMap = (Map)this.copyOnThreadLocal.get(); if (oldMap != null) &#123; Integer lastOp = this.getAndSetLastOperation(1); if (this.wasLastOpReadOrNull(lastOp)) &#123; Map&lt;String, String&gt; newMap = this.duplicateAndInsertNewMap(oldMap); newMap.remove(key); &#125; else &#123; oldMap.remove(key); &#125; &#125; &#125; &#125; public void clear() &#123; this.lastOperation.set(Integer.valueOf(1)); this.copyOnThreadLocal.remove(); &#125; public String get(String key) &#123; Map&lt;String, String&gt; map = (Map)this.copyOnThreadLocal.get(); return map != null &amp;&amp; key != null ? (String)map.get(key) : null; &#125; public Map&lt;String, String&gt; getPropertyMap() &#123; this.lastOperation.set(Integer.valueOf(2)); return (Map)this.copyOnThreadLocal.get(); &#125; public Set&lt;String&gt; getKeys() &#123; Map&lt;String, String&gt; map = this.getPropertyMap(); return map != null ? map.keySet() : null; &#125; public Map&lt;String, String&gt; getCopyOfContextMap() &#123; Map&lt;String, String&gt; hashMap = (Map)this.copyOnThreadLocal.get(); return hashMap == null ? null : new HashMap(hashMap); &#125; public void setContextMap(Map&lt;String, String&gt; contextMap) &#123; this.lastOperation.set(Integer.valueOf(1)); Map&lt;String, String&gt; newMap = Collections.synchronizedMap(new HashMap()); newMap.putAll(contextMap); this.copyOnThreadLocal.set(newMap); &#125;&#125; 从源码中看出，核心思想还是ThreadLocal1234final ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = new ThreadLocal();private static final int WRITE_OPERATION = 1;private static final int MAP_COPY_OPERATION = 2;final ThreadLocal&lt;Integer&gt; lastOperation = new ThreadLocal(); 定义了2个ThreadLocal，一个维护着Map，这就是我们在使用时自己定义的追踪数据，另一个ThreadLocal记录着该线程的操作记录，需要注意，在上面的代码中，write操作即put会去修改lastOperation，而get操作则不会。这样就保证了，只会在第一次写时复制。 MDC的使用定义全局拦截器 MDC的使用很简单，只需要调用put方法就行，MDC.put(“traceId”, “traceId”),再结合HandlerInterceptor的使用，可以在所有的请求中都加上日志追踪，就无需手动在每个请求中加了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.smart.server.interceptor;import org.slf4j.MDC;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import java.lang.reflect.Method;import java.util.UUID;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;/** * ClassName: TimeHandlerInterceptor &lt;br/&gt; Function: 方法执行时间拦截器. &lt;br/&gt; date: 2017年3月23日 下午8:46:58 * &lt;br/&gt; * * author gaowenming since JDK 1.8 */@Slf4jpublic class TimeHandlerInterceptor implements HandlerInterceptor &#123; // 当前时间戳 private ThreadLocal&lt;Long&gt; threadLocalTime = new ThreadLocal&lt;&gt;(); /** * controller 执行之前调用 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //日志追加traceId追踪 MDC.put("traceId", "traceId=" + UUID.randomUUID().toString().replace("-", "")); long startTime = System.currentTimeMillis(); threadLocalTime.set(startTime); return true; &#125; /** * controller 执行之后，且页面渲染之前调用 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); long endTime = System.currentTimeMillis(); long startTime = threadLocalTime.get(); long executeTime = endTime - startTime; log.info("[&#123;&#125;.&#123;&#125;] 执行耗时:&#123;&#125;ms", method.getDeclaringClass().getName(), method.getName(), executeTime); &#125; /** * 页面渲染之后调用，一般用于资源清理操作 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; MDC.clear(); &#125;&#125; 定义一个全局拦截器，拦截所有的Controller请求，在preHandle方法中，调用MDC.put(“traceId”, “traceId=” + UUID.randomUUID().toString().replace(“-“, “”));这样traceId就会被加到该请求所有的链路中，在afterCompletion方法中clear，确保本次请求完成后，MDC中的数据要清空。该拦截器中还加入了方法的执行时间统计，原理和MDC类似，使用ThreadLocal。 修改logback.xml文件 上面我们往MDC中put了traceId的key，再把这个key增加到logback.xml文件中即可12345&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;%date %level %X&#123;traceId&#125; [%thread] %logger&#123;50&#125;-[%line] %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; 配置完logback文件后，然后就可以正常打印了 1232017-12-30 10:48:53,986 INFO traceId=73eb01785cce4ce8812dd091b07c2ccd [http-nio-8000-exec-8] 2017-12-30 10:48:53,987 WARN traceId=73eb01785cce4ce8812dd091b07c2ccd [http-nio-8000-exec-8] 2017-12-30 10:48:53,988 ERROR traceId=73eb01785cce4ce8812dd091b07c2ccd [http-nio-8000-exec-8] 到此，MDC的使用就介绍完了，其实总结起来也挺简单的，核心就是ThreadLocal，配置也非常简单，但是功能确很强大，很大的方便了我们对日志的追踪。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>MDC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc全局异常处理]]></title>
    <url>%2F2017%2F12%2F28%2FSpringMvc%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理是开发中不可避免的，好的异常处理方式，能提高代码的可读性，使代码更简洁，本文就介绍下在开发Rest接口时，如何优雅的处理异常。 如何抛出异常 java中异常分为2类：预期异常和运行时异常RuntimeException，预期异常就是需要明确的捕获异常，比如文件读写时，需要捕获IOException。运行时异常，无法预知的异常，比如著名的NullPointException。那么我们在定义接口时，怎么定义异常呢？一个原则，就是尽量在调用的最上层处理。 比如一个调用连中，Http-&gt;Controller-&gt;Service-&gt;Dao-&gt;DB,Controller层负责和调用端的数据交互，一般都会包含请求的响应状态，成功还是失败，返回的数据，通常我们都会定义一个通用的返回体，包含Code，Msg，ResultData，Service层负责具体的业务逻辑，Dao层负责与DB的交互。 正常成功的请求，可以在Controller层定义，但是各种系统的异常情况怎么优雅的处理呢？答案就是抛出异常。我们定义好业务异常(BusinessException),定义好异常code和异常信息Msg，在业务出现异常的情况时，直接抛出异常信息，由Controller层统一处理，Service层只需要在遇到异常时，直接Throw就可以，这样既能阻止程序继续往下执行，也避免了代码中无限的return。 定义业务异常 上面介绍了业务异常通用类，主要包含异常代码，异常信息，具体的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BusinessException extends RuntimeException &#123; private static final long serialVersionUID = 1L; private BusinessErrorMsg businessErrorMsg; public BusinessException(BusinessErrorMsg businessErrorMsg) &#123; this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; this.businessErrorMsg = businessErrorMsg; &#125; public BusinessException() &#123; this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessException(BusinessErrorMsg businessErrorMsg, Throwable cause) &#123; this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; this.businessErrorMsg = businessErrorMsg; &#125; public BusinessException(String message, Throwable cause) &#123; super(message, cause); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessException(String message) &#123; super(message); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; protected BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessException(Throwable cause) &#123; super(cause); this.businessErrorMsg = BusinessErrorMsg.SYSTEM_ERROR; &#125; public BusinessErrorMsg getBusinessErrorMsg() &#123; return this.businessErrorMsg; &#125; public void setBusinessErrorMsg(BusinessErrorMsg businessErrorMsg) &#123; this.businessErrorMsg = businessErrorMsg; &#125;&#125; 异常代码我们使用枚举的方式12345678910111213141516171819202122232425262728293031package com.smart.service.base;public enum BusinessErrorMsg &#123; SYSTEM_ERROR(Integer.valueOf(9999), "系统错误"), VALIDATION_TOKEN_NULL(Integer.valueOf(1000), "token is null"), VALIDATION_PARAM_ERROR(Integer.valueOf(1001), "参数错误"); private Integer errorCode = Integer.valueOf(9999); private String errorMessage = "系统错误"; private BusinessErrorMsg(Integer errorCode, String errorMessage) &#123; this.errorCode = errorCode; this.errorMessage = errorMessage; &#125; public Integer getErrorCode() &#123; return this.errorCode; &#125; public void setErrorCode(Integer errorCode) &#123; this.errorCode = errorCode; &#125; public String getErrorMessage() &#123; return this.errorMessage; &#125; public void setErrorMessage(String errorMessage) &#123; this.errorMessage = errorMessage; &#125;&#125; 使用枚举的好处就是比较直观，code和msg一一对应 全局异常处理异常定义好了，那怎么能优雅的捕获呢？SpringMvc提供了全局RestControllerAdvice，顾名思义，RestController的拦截器，使用这种方式，我们就不用在Controller层使用try/catch了，直接交给异常处理器就ok了，是不是很方便呢。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.smart.server.handler;import com.smart.server.base.BaseJsonResult;import com.smart.service.base.BusinessErrorMsg;import com.smart.service.base.BusinessException;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.Arrays;import java.util.Map;import javax.servlet.http.HttpServletRequest;import lombok.extern.slf4j.Slf4j;/** * 全局异常处理 * * 2017年4月28日 下午10:14:26 &lt;br/&gt; * * author gaowenming version since JDK 1.8 */@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123; /** * 系统异常 * * @author gaowenming param req param e return throws Exception since JDK 1.8 */ @ExceptionHandler(value = Exception.class) @ResponseBody public BaseJsonResult&lt;Object&gt; defaultExceptionHandler(HttpServletRequest req, Exception e) throws Exception &#123; log.error("&lt;-----------------系统响应异常-----------------&gt;", e); printMethodParameters(req); BaseJsonResult&lt;Object&gt; baseJsonResult = new BaseJsonResult&lt;&gt;(); baseJsonResult.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); baseJsonResult.setMsg("请求失败,请稍后重试！"); return baseJsonResult; &#125; /** * 业务异常 * * @author gaowenming param req param e return throws Exception since JDK 1.8 */ @ExceptionHandler(value = BusinessException.class) @ResponseBody public BaseJsonResult&lt;Object&gt; smartBusinessExceptionHandler(HttpServletRequest req, BusinessException e) throws Exception &#123; BaseJsonResult&lt;Object&gt; baseJsonResult = new BaseJsonResult&lt;&gt;(); BusinessErrorMsg businessErrorMsg = e.getBusinessErrorMsg(); log.warn("catch BusinessException,code:&#123;&#125;,message:&#123;&#125;", businessErrorMsg.getErrorCode(), businessErrorMsg.getErrorMessage()); printMethodParameters(req); baseJsonResult.setStatus(businessErrorMsg.getErrorCode()); baseJsonResult.setMsg(businessErrorMsg.getErrorMessage()); return baseJsonResult; &#125; /** * 记录方法的入参 */ private static void printMethodParameters(HttpServletRequest request) &#123; StringBuilder methodInfo = new StringBuilder(); methodInfo.append("url=").append(request.getServletPath()); methodInfo.append(" ;params= "); if (request.getQueryString() != null) &#123; methodInfo.append(request.getQueryString()).append(" - "); &#125; else &#123; Map&lt;String, String[]&gt; parameters = request.getParameterMap(); if (parameters.size() != 0) &#123; methodInfo.append(" ["); &#125; for (Map.Entry&lt;String, String[]&gt; entry : parameters.entrySet()) &#123; String key = entry.getKey(); Object value = entry.getValue(); String message = ""; if (value.getClass().isArray()) &#123; Object[] args = (Object[]) value; message = " " + key + "=" + Arrays.toString(args) + " "; &#125; else &#123; message = key + "=" + String.valueOf(value) + " "; &#125; methodInfo.append(message); &#125; if (parameters.size() != 0) &#123; methodInfo.append("]"); &#125; &#125; log.info(methodInfo.toString()); &#125;&#125; 定义GlobalExceptionHandler，加上@RestControllerAdvice注解，这样就表示拦截Controller所有的异常情况了，我们可以使用@ExceptionHandler注解，处理不同类型的异常。推荐大家把异常发生时的入参都打印出来，这样能够方便我们在出现异常时快速的定位问题。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于注解的Token校验方案]]></title>
    <url>%2F2017%2F12%2F26%2F%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Token%E6%A0%A1%E9%AA%8C%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在后端开发中，通常需要对接口做权限校验，校验用户是否需要登录，是否需要认证等等，本文就来介绍下如何通过注解的方式来对Token做认证 注解定义 其实说到用户认证，大家脑海中肯定会想到拦截器（Interceptor）和过滤器（Filter），那么怎样才能更灵活的实现呢？注解毫无疑问就派上用场了。 首先定义注解：1234567891011121314151617package com.smart.server.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * token注解，可用于类、方法中，拦截token验证 * * Created by gaowenming on 2017/6/15. */@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface TokenValidation &#123; String name() default "";&#125; 定义一个注解TokenValidation，Target的作用范围是TYPE和METHOD，也就是可以在Class类上，也可以在方法上，如果是在类上使用注解，表示该类所有的方法都需要进行Token的校验，如果在方法上，表示该方法需要进行认证。 注解实现 注解定义好了,我们基于AOP的方式，对注解进行拦截123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.smart.server.util.Constants;import com.smart.service.base.BusinessErrorMsg;import com.smart.service.base.BusinessException;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import lombok.extern.slf4j.Slf4j;/** * Created by gaowenming on 2017/6/15. */@Aspect@Component@Slf4jpublic class TokenValidationInterceptor &#123; //注解在类上面@within @Pointcut("@within(com.smart.server.annotation.TokenValidation)") public void pointcut() &#123; &#125; @Before("pointcut()") public void tokenValidationType(JoinPoint point) throws Throwable &#123; commonTokenValidation(point); &#125; //注解在方法上面@annotation @Pointcut("@annotation(com.smart.server.annotation.TokenValidation)") public void pointcutMethod() &#123; &#125; @Before("pointcutMethod()") public void tokenValidationMethod(JoinPoint point) throws Throwable &#123; commonTokenValidation(point); &#125; //公共的校验 public static void commonTokenValidation(JoinPoint point) throws Throwable &#123; HttpServletRequest request; RequestAttributes ra = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes sra = (ServletRequestAttributes) ra; request = sra.getRequest(); String url = request.getServletPath(); String token = request.getHeader(Constants.TOKEN_NAME); log.info("TokenHandlerInterceptor----- url:&#123;&#125;,token:&#123;&#125; ", url, token); if (StringUtils.isEmpty(token)) &#123; throw new BusinessException(BusinessErrorMsg.VALIDATION_TOKEN_NULL); &#125; //校验token是否过期和正确 //TODO &#125;&#125; 上面的实现，做个简单的说明，首先我们约定好，token封装在Http请求的Header中，拦截器上中先从Header中获取token的值，然后判断token是否为空，如果不为空，还需要判断token是否过期，是否正确。在实际项目中，用户登录后，服务端会根据一定的算法计算出token的值，然后把该token的值放入Redis中，并设置有效期，这样就很方便的处理过期的问题。 注解使用经过上面的2步，就可以在我们定义的Controller中使用我们定义的注解了12345678910111213141516171819202122232425262728293031323334353637383940414243package com.smart.server.controller;import com.smart.model.Dic;import com.smart.server.annotation.TokenValidation;import com.smart.server.base.BaseController;import com.smart.server.base.BaseJsonResult;import com.smart.service.IDicService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import io.swagger.annotations.Api;import lombok.extern.slf4j.Slf4j;@RestController@RequestMapping("api/dic/")@Api@Slf4jpublic class DicController extends BaseController &#123; @Autowired private IDicService dicService; @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) public BaseJsonResult&lt;Dic&gt; getDic(@PathVariable Integer id) throws Exception &#123; log.info("getDic......."); Dic dic = dicService.get(id); return successResult(dic); &#125; @RequestMapping(value = "/addDic", method = RequestMethod.POST) @TokenValidation public BaseJsonResult addDic(@RequestBody Dic dic) throws Exception &#123; log.info("addDic......."); dicService.save(dic); return successNullDataResult(); &#125;&#125; 是不是很方便，get操作不需要校验，就无需增加注解，在add操作中，增加token校验，加上注解即可。 为什么用注解 使用注解的方式，你会发现非常灵活，类和方法可以自己灵活设置，处理逻辑使用AOP的方式统一处理。其实还有其他的一些使用场景，比如有些接口返回值需要加密返回，也可以使用类似的注解方式实现。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis解决定时任务在分布式环境单节点执行]]></title>
    <url>%2F2017%2F12%2F24%2FRedis%E8%A7%A3%E5%86%B3%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E5%8D%95%E8%8A%82%E7%82%B9%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[定时任务，在日常开发中是经常用到的，在分布式环境中，定时任务的执行往往需要控制多节点同时执行的问题，比如可以借助Quartz，或者分布式锁，本文提供另一种解决方式，也是借助Redis。 实现方式 在Redis中，提供了自增和增减的相关命令，来保证计数的原子性 incr 递增1并返回递增后的结果；incrby 根据指定值做递增或递减操作并返回递增或递减后的结果(incrby递增或递减取决于传入值的正负)decr 递减1并返回递减后的结果；decrby 根据指定值做递增或递减操作并返回递增或递减后的结果(decrby递增或递减取决于传入值的正负) 了解了上面几个命令之后，在来说通过计数器来控制并发执行，应该就很容易理解了直接上代码吧：1234567long jobKeyValue = redisKeyValueResolver.increment(ExdataConstants.JOB_KEY);LOGGER.debug("jobKeyIncrementAfterValue:&#123;&#125;", jobKeyValue); if (jobKeyValue == 1) &#123; //一秒失效 redisKeyValueResolver.expireKey(ExdataConstants.JOB_KEY, 1); //业务逻辑。。。 &#125; 上面一段代码，首先定义一个key，当定时任务触发时，多个节点同时执行incr自增操作,第一个执行自增的节点的值就是1，其他的节点就是2、3、4…根据自增后的值来控制定时任务的执行，也就可以有效的控制只执行一次了。 当然还是需要注意，一定要在if语句块最前面执行expire操作，因为执行业务逻辑需要时间，更有可能出现异常，所以在最前面设置过期时间，保证了下次定时任务执行时，key已失效。 不需要使用较重的分布式锁，巧妙的运用了Redis的原子操作，这样是的实现方式是不是更简单呢?]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j的debug日志引起的线上故障]]></title>
    <url>%2F2017%2F12%2F22%2FLog4j%E7%9A%84debug%E6%97%A5%E5%BF%97%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%2F</url>
    <content type="text"><![CDATA[前天下午，运维突然在微信群里说系统流量下跌了，报警邮件也马上来了，都是api接口的time out，查看各种监控工具，zabbix，oneapm，es集群，除了发现流量有下跌，没有别的异常情况。 错误现象 入口流量没有明显增加查看了流量监控，入口流量并没有出现爆发式的增长，很平稳，毕竟我们的流量高峰是在上午，下午3点很难出现高峰 内存、CPU没有明显波动查看系统的运行状态，内存、CPU都没有出现大的波动，说明并没有出现大的计算任务，如果有计算型的任务，会消耗大量的内存和CPU资源 线程数上升迅猛看监控，配置的Tomcat的线程池满了，直接导致了系统的请求超时。[图片] 异常原因分析 既然已经确认是由于线程池的堆积，造成系统的调用超时，那么为什么会突然之间线程池暴涨呢？原因竟然是由于一个同事开启了线上的debug日志跟踪一个问题，持续时间大概20分钟，那么问题来了，log4j开启debug日志，为什么会导致线程池暴涨，造成系统崩溃呢？ 由于log4j同步打日志，当debug日志过多时，频繁的写磁盘文件，api请求的耗时就会增加，那么该api占用的线程的时间就会变长，当占用时间过长，导致线程池不够时，就会出现等待的情况，持续时间一长，等待的线程越来越多，那么就会出现time out了 如何解决 规范日志的打印日志打印不是越多越好，其实只要关键位置的日志往往就可以，比如方法的入口和出口，逻辑的分叉，try/catch的异常日志 异常信息的拼装往往debug的时候，打印日志都是很详细的，比如某个对象的完整信息，Http的完整响应等，这些信息都是比较大的，这时候如果用log.debug(Json.toJSONString(user));也许你觉得这么写也没有什么问题啊，其实不然，虽然如果你设置info级别，这个debug日志是不会打印，但是它会执行Json的转换，这其实也是损耗性能的，系统的性能往往就是细节地方不注意，累计多了，就会出现瓶颈。这时，可以使用级别判断来解决这个问题 if(log.isDebugEnable) { LOG.debug(“params = {}”, JSON.toJSONString(user)); } 可以采用logback、log4j2来替换log4j。log4j2已经发行了稳定版本，logback是基于slf4j的门面实现，性能都比log4j高不少]]></content>
      <categories>
        <category>故障分析</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装Docker]]></title>
    <url>%2F2017%2F12%2F05%2FCentos7%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"><![CDATA[在工作中,总是避免不了搭建各种开发环境，配置各种组件的环境变量，如果你厌倦了以往的方式，你可以尝试使用Docker，本文就从Docker的安装开始。 安装说明 Docker支持以下的CentOS版本：CentOS 7 (64-bit)CentOS 6.5 (64-bit) 或更高的版本前提条件目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 yum安装docker 1.使用root权限登陆系统。 2.更新系统包到最新。 yum -y update 3、安装docker yum -y install docker 4、启动docker服务 systemctl start docker.service 5、创建开机启动Docker服务 systemctl enable docker.service 6、查看Docker版本号 docker version 7、运行hello-world docker run hello-world 后续后续的组件，我会尽量用Docker的方式来处理，这样既方便快捷，也完美的解决了一台机器中安装某个服务的多个版本，比如es，redis，后面也会在使用中总结更多的用法。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat的线程安全问题]]></title>
    <url>%2F2017%2F11%2F26%2FSimpleDateFormat%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat在进行日期格式转换时用的很多，但是 DateFormat 和 SimpleDateFormat 类不都是线程安全的，在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题 多线程测试12345678910111213141516 * &lt;p&gt; * Date formats are not synchronized. * It is recommended to create separate format instances for each thread. * If multiple threads access a format concurrently, it must be synchronized * externally. * * @see &lt;a href="http://java.sun.com/docs/books/tutorial/i18n/format/simpleDateFormat.html"&gt;Java Tutorial&lt;/a&gt; * @see java.util.Calendar * @see java.util.TimeZone * @see DateFormat * @see DateFormatSymbols * @author Mark Davis, Chen-Lieh Huang, Alan Liu */public class SimpleDateFormat extends DateFormat &#123;...................｝ 在注视中，明确说明If multiple threads access a format concurrently, it must be synchronized测试代码：12345678910111213141516171819202122public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; 上面的测试方法在多线程下会出现如下异常：123456789101112131415161718192021222324252627282930313233343536Exception in thread "Thread-1" Exception in thread "Thread-3" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)Exception in thread "Thread-8" java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2088)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745)java.lang.NumberFormatException: For input string: ""trueat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)trueat java.lang.Long.parseLong(Long.java:453)trueat java.lang.Long.parseLong(Long.java:483)trueat java.text.DigitList.getLong(DigitList.java:194)trueat java.text.DecimalFormat.parse(DecimalFormat.java:1316)trueat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)trueat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)trueat java.text.DateFormat.parseObject(DateFormat.java:415)trueat java.text.Format.parseObject(Format.java:243)trueat com.smart.tools.SimpleDateFormatTest$1.run(SimpleDateFormatTest.java:32)trueat java.lang.Thread.run(Thread.java:745) 根本原因SimpleDateFormat继承了DateFormat,在DateFormat中定义了一个protected属性的 Calendar类的对象：calendar。只是因为Calendar累的概念复杂，牵扯到时区与本地化等等，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。 在format方法里，有这样一段代码：12private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // Convert input date to time field list calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法： 线程1调用format方法，改变了calendar这个字段。 中断来了。 线程2开始执行，它也改变了calendar。 又中断了。 线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。 分析一下format的实现，我们不难发现，用到成员变量calendar，唯一的好处，就是在调用subFormat时，少了一个参数，却带来了这许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。 这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。 解决办法 每次需要的时候都创建一个新的实例 使用同步：同步SimpleDateFormat对象 使用common-lang中的api中的FastDateFormat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.CountDownLatch;import org.apache.commons.lang3.time.FastDateFormat;import org.junit.Test;/** * 测试时间处理类的线程安全问题 * @Description * @author gaowenming */public class SimpleDateFormatTest &#123; public static final String PATTEN = "yyyy-MM-dd hh:mm:ss"; public static final SimpleDateFormat sdf = new SimpleDateFormat(PATTEN); public static final CountDownLatch countDownLatch = new CountDownLatch(100); @Test public void testJDKSimpleDateFormat() &#123; //jdk的实现方式，会有线程安全的问题 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(sdf.parseObject("2013-05-24 06:02:20")); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; @Test public void testCommonLang() &#123; //CommonLang第三方jar包实现 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; FastDateFormat fdf = FastDateFormat.getInstance(PATTEN); System.out.println(fdf.format(new Date())); Date date = fdf.parse("2013-05-24 06:02:20"); System.out.println(date); countDownLatch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; try &#123; //等待100个线程都执行完 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
</search>
